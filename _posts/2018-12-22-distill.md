---
layout: distill
title: "Investigation about Optimal LLM Scale for 1-Bit Training"
description: As the bit width decreases, the model size required to maintain the same level of performance increases; conversely, if the model becomes excessively large, the benefits of memory and compute reduction are significantly diminished. In this work, we quantitatively evaluate the “minimum model scale needed to achieve performance comparable to an FP16 baseline” for each of the leading 1-bit and sub-1-bit quantization methods published since 2023."


tags: distill formatting
giscus_comments: true
date: 2021-05-22
featured: true
mermaid:
  enabled: true
  zoomable: true
code_diff: true
map: true
chart:
  chartjs: true
  echarts: true
  vega_lite: true
tikzjax: true
typograms: true

authors:
  - name: Hyeon-seok Shin
    url: "https://en.wikipedia.org/wiki/Albert_Einstein"
    affiliations:
      name: POSTECH, Republic of Korea

bibliography: 2018-12-22-distill.bib

# Optionally, you can add a table of contents to your post.
# NOTES:
#   - make sure that TOC names match the actual section names
#     for hyperlinks within the post to work correctly.
#   - we may want to automate TOC generation in the future using
#     jekyll-toc plugin (https://github.com/toshimaru/jekyll-toc).
toc:
  - name: Introduction
    # if a section has subsections, you can add them as follows:
    # subsections:
    #   - name: Example Child Subsection 1
    #   - name: Example Child Subsection 2
  - name: Related work about quantization method (1-bit or sub 1-bit)
    subsections:
    - name: BitNet
    - name: BitNet 1.58
    - name: Sub 1-bit Quantization, STBLLM
  - name: Methodology for Finding the Optimal Model Size & Results
    subsections:
    - name: Zero-shot Accuracy Perspective
    - name: Perplexity Perspective
    - name: Holistic Evaluation
  - name: Contribution & Conclusion
  - nmae: Limitation

# Below is an example of injecting additional post-specific styles.
# If you use this post as a template, delete this _styles block.
_styles: >
  .fake-img {
    background: #bbb;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 0px 4px rgba(0, 0, 0, 0.1);
    margin-bottom: 12px;
  }
  .fake-img p {
    font-family: monospace;
    color: white;
    text-align: left;
    margin: 12px 0;
    text-align: center;
    font-size: 16px;
  }
---

## Introduction

Since the introduction of the Transformer architecture, large language models have leveraged tens to hundreds of billions of parameters to achieve remarkable language generation capabilities. However, as the model grows in size, training the model requires excessive time, resources, and energy, making it challenging for real-world deployment and low-power edge utilization.
<div style="text-align: center;">
  <img
    src="/assets/img/modelsizeup.png"
    alt="BitNet Architecture"
    style="max-width: 100%; height: auto; object-fit: contain;"
  />
</div>
<br>

To mitigate these challenges, 8-bit and 4-bit quantization techniques have been adopted to reduce memory usage with minimal performance loss compared to FP16, but when bit-width is reduced below 2 bits, both perplexity and zero-shot accuracy suffer drastic degradation <a href="https://arxiv.org/abs/2502.13179" style="color:blue;">[1]</a>.  Extreme 1-bit quantization offers the potential to reduce storage and bandwidth requirements by up to 32× <a href="https://link.springer.com/chapter/10.1007/978-3-319-46493-0_32" style="color:blue;">[2]</a>, but to offset the information loss from lower bit-widths, the model must be scaled up significantly. However, if the model size is unnecessarily increased, not only performance improvement becomes insignificant, but additional computational resources and energy consumption increase and practical distribution becomes difficult. To that end, quantifying the minimum model size will be essential in terms of model distribution and operational cost-effectiveness. So identifying the “optimal model size” that maintains FP16-level performance while still achieving efficient resource savings is essential.

In particular, PTQ (Post-Training Quantization) and QAT (Quantization-Aware Training) require very different model scales, yet to date no study has quantitatively defined the optimal sizes for these two approaches. In this work, we conduct a thorough survey of the leading 1-bit training methods published since 2023 and experimentally determine the PTQ- and QAT-optimized model scales, providing concrete guidelines for balancing target performance and resource constraints when designing and deploying 1-bit LLMs.

## Related work about quantization method (1-bit or sub 1-bit)

### BitNet (2023) <a href="https://arxiv.org/abs/2310.11453">[3]
</a>
This was the first study to introduce QAT to a 1-bit LLM. In that paper, the authors proposed a scalable and stable 1-bit Transformer architecture and, in particular, introduced BitLinear, a 1-bit weight layer that can replace the standard fully connected layer.

<div style="text-align: center;">
  <img
    src="/assets/img/BitNet.png"
    alt="BitNet Architecture"
    style="max-width: 100%; height: 300px; object-fit: contain;"
  />
</div>
<br>
BitNet retains the familiar Transformer stacking of self-attention and feed-forward blocks, but replaces all weight matrix multiplications with BitLinear, which uses 1-bit weights. All other operations—including residual connections and LayerNorm—remain in 8-bit precision. This design choice is justified because (1) residual paths and LayerNorm incur only negligible compute and memory cost compared to the core Transformer operations, and (2) high-precision probabilities are required for accurate sampling.
<details>
  <summary style="color: green;">View BitLinear's quantization & computational procedures</summary>
1. **Weight Binarization**  
   First, the weight $W$ is binarized to \(\{+1, -1\}\) via a sign function.  
   To zero-center the weights, subtract the mean $\alpha$, then use the scale factor  $\alpha$ to minimize the binarization error.  
   
   $$
   \alpha = \frac{1}{nm} \sum_{i,j} W_{ij},  
   \quad  
   \widetilde{W} = \operatorname{Sign}(W - \alpha),  
   \quad  
   \operatorname{Sign}(x) =  
   \begin{cases}  
     +1, & x > 0,\\  
     -1, & x \le 0.  
   \end{cases}  
   $$

2. **Activation AbsMax Quantization**  
   The activation  $x$ is quantized to $b$ bits.  
   
   $$
   \widetilde{x} = \mathrm{Quant}(x) 
     = \mathrm{Clip}\!\Bigl(x \times \tfrac{Q_b}{\gamma},\,-Q_b + \epsilon,\;Q_b - \epsilon\Bigr),  
   $$
   $$  
   \mathrm{Clip}(z,a,b) = \max\!\bigl(a,\min(b,z)\bigr),  
   $$
   $$  
   \gamma = \|x\|_\infty.
   $$

   Then, subtract the minimum $\eta$ = $\min_{i,j} x_{ij}$ from all values to shift into a fixed positive range, and apply the same quantization:

   $$
   \widetilde{x} = \mathrm{Quant}(x) 
     = \mathrm{Clip}\!\Bigl((x - \eta)\times \tfrac{Q_b}{\gamma},\,-Q_b+\epsilon,\;Q_b-\epsilon\Bigr),  
   \quad  
   \eta = \min_{i,j} x_{ij}.
   $$

3. **Matrix Multiplication**  
   Perform matrix multiplication using the binarized weight $\widetilde{W}$ and the quantized activation $\widetilde{x}$:

   $$
   y = \widetilde{W}\,\widetilde{x}.
   $$

4. **LayerNorm for Variance Preservation**  
   To ensure the output variance $\mathrm{Var}(y)\approx 1$, apply LayerNorm before activation quantization.  
   Using Sub-LayerNorm and the aforementioned quantization methods, the BitLinear layer is defined as:

   $$
   \begin{aligned}
     y &= \widetilde{W}\,\mathrm{Quant}\bigl(\mathrm{LN}(x)\bigr)\times \frac{\beta\,\gamma}{Q_b},\\
     \mathrm{LN}(x) &= \frac{x - \mathbb{E}[x]}{\sqrt{\mathrm{Var}(x) + \epsilon}},  
     \quad  
     \beta = \frac{1}{nm}\|W\|_{1}.
   \end{aligned}
   $$
</details>

### BitNet 1.58 (2024) <a href="https://arxiv.org/abs/2402.17764">[4]</a>
Based on the BitNet Transformer architecture (replacing `nn.Linear` with `BitLinear`), BitNet b1.58 trains with **1.58-bit weights** and **8-bit activations**.

- All weight parameters are fixed to **\(\{-1, 0, +1\}\)**,  
  preserving BitNet’s compression and compute advantages while  
  virtually eliminating standard matrix multiplications.
<div style="text-align: center;">
  <img
    src="/assets/img/bitnet1.58.png"
    alt="BitNet Architecture"
    style="max-width: 100%; height: auto; object-fit: contain;"
  />
</div>
<br>

- Key benefits:  
  1. Dramatically reduced memory footprint.  
  2. Explicit feature filtering via zero-valued weights improves performance.  
  3. Perplexity and downstream task performance are on par with FP16.
<br>
<details>
  <summary style="color: green;">AbsMean Quantization Function</summary>
 
 **AbsMean Quantization Function**

1. **Scaling**
   Scale the weight matrix  $W$ by its average absolute value $\gamma$.  
2. **Round & Clip**
   Round and clamp each element to the nearest value in \(\{-1, 0, +1\}\).  
   $$
   \widetilde{W} = \mathrm{RoundClip}\!\Bigl(\frac{W}{\gamma + \epsilon}, -1, +1\Bigr),  
   $$
   $$
   \mathrm{RoundClip}(x,a,b) = \max\bigl(a,\min(b,\mathrm{round}(x))\bigr),  
   $$
   $$
   \gamma = \frac{1}{nm}\sum_{i,j} |W_{ij}|.
   $$
</details>


### Sub 1-bit Quantization, STBLLM (2024) <a href="https://arxiv.org/abs/2408.01803">[5]</a>

STBLLM (Structured Binary LLM) is a new compression framework that structurally binarizes large language models (LLMs) beyond conventional 1-bit precision.   While LLMs offer state-of-the-art performance, their high memory and compute demands limit deployment on resource-constrained environments. STBLLM observes that flipping a portion of binary weights in 1-bit LLMs does **not significantly degrade performance**, suggesting room for more aggressive compression.
<div style="text-align: center;">
  <img
    src="/assets/img/stbllm_1.png"
    alt="BitNet Architecture"
    style="max-width: 100%; height: auto; object-fit: contain;"
  />
</div>
<br>
<details>
  <summary style="color: green;">Summary of STBLLM Four Key Techniques</summary>

**1. Structured Sparsity with N:M Pattern**

- STBLLM employs N:M structured pruning to encode \(N\) non-zero weights in every \(M\)-slot group, enabling **extremely high compression**.
<br>
- This pattern is also hardware-friendly and supports **accelerated inference**.

**2. Standardized Importance (SI) Metric**

- To overcome the instability of Hessian-based importance scores, STBLLM proposes a lightweight importance metric that considers both weight magnitude and input feature norm.
<br>
- Importance formula:  
  $$
  S_{i,j} = \sigma\bigl(\mu(|W_{i,j}|)\bigr) \cdot \left\| X_{:,j} \right\|_2
  $$
  - $\mu$: Mean of absolute weights  
  - $\sigma$: Normalization function  
  - $X$: Input feature matrix

**3. Layer-wise Adaptive Binarization**

- Each layer’s relative importance $\alpha_i$ is computed and used to apply  **aggressive compression for less critical layers**, and **preserve more precision in key layers**.
<br>
- Formula:  
  $$
  \alpha_i = \frac{\omega_i}{\omega_{\text{total}}}
  $$
  - $\omega_i$ = $\|W_i\|_2$: L2 norm of layer \(i\)  
  - $\omega_{\text{total}}$: Sum of norms across all layers

**4. Non-salient Aware Quantization**

- Weights are divided into three zones based on their importance: **sparse**, **intermediate**, and **dense**.
<br>
- Different binarization strategies are applied to each zone to reduce total bit usage while maintaining task-level performance.
</details>

## Methodology for Finding the Optimal Model Size & Results

### Zero-shot Accuracy Perspective


**1. Extracting the 90% Threshold**
- For each paper and zero-shot benchmark, we determine the minimum model size required to reach 90% of the FP16 baseline accuracy.

**2. Adjusting for Under-Reporting**
- If even the largest reported scale fails to hit 90%, we multiply that maximum scale by 1.5 to estimate the required size (e.g., if a 3B model falls short, we assume 4.5B would meet the threshold).

**3. Averaging**
- We first average the required scales across shared benchmarks (ARC, HellaSwag, etc.), then compute separate averages for PTQ and QAT to obtain representative values.


Based on our survey of references [4]–[8], we extracted the optimal model sizes required to approach FP16 performance. 
<div style="text-align: center;">
  <img
    src="/assets/img/PTQ_table.png"
    alt="PTQ vs QAT Table"
    style="max-width: 100%; height: auto; object-fit: contain;"
  />
</div>

<br>

<div style="text-align: center;">
  <img
    src="/assets/img/QAT_table.png"
    alt="BitNet Architecture"
    style="max-width: 100%; height: auto; object-fit: contain;"
  />
</div>
<br>
As shown in the table below, values highlighted in red indicate cases where even the largest model reported in the paper failed to reach 90% accuracy; in those instances, we adjusted the estimate by multiplying the maximum model size by 1.5. Since the zero-shot benchmarks vary across studies, we computed the average only over benchmarks common to all papers (highlighted in orange color).
<br>
<br>
<div style="text-align: center;">
  <img
    src="/assets/img/PTQ_QAT_graph.png"
    alt="BitNet Architecture"
    style="max-width: 100%; height: auto; object-fit: contain;"
  />
</div>
<br>

The accompanying chart clearly demonstrates that PTQ methods require substantially larger model sizes compared to QAT approaches.


### Perplexity Perspective

**1. Establishing a PPL ≤ 10 Criterion**
- Because some methods exceed the baseline PPL and others omit data, we set a consistent standard of PPL ≤ 10.

**2. Collecting Required Scales**
- We gather the model sizes reported for PTQ and QAT methods that satisfy the PPL ≤ 10 criterion.

**3. Averaging**
- We average these scales separately for PTQ and QAT, yielding comparable insights between the two approaches.

<div style="text-align: center;">
  <img
    src="/assets/img/PPL_table.png"
    alt="BitNet Architecture"
    style="max-width: 100%; height: auto; object-fit: contain;"
  />
</div>
<br>

In terms of PPL, the PTQ method requires more than 9 times the model size compared to the QAT method.


### Holistic Evaluation
<div style="text-align: center;">
  <img
    src="/assets/img/ZeroPPL.png"
    alt="BitNet Architecture"
    style="max-width: 100%; height: auto; object-fit: contain;"
  />
</div>
<br>

As you can see in the graph above, PTQ requires an average of 31.6 - 47.8 B model, but QAT is sufficient around 6.7 B.

<div style="text-align: center;">
  <img
    src="/assets/img/PTQ_QAT_Ref.png"
    alt="BitNet Architecture"
    style="max-width: 100%; height: auto; object-fit: contain;"
  />
</div>
<br>

It is believed that QAT requires a smaller model than PTQ because PTQ only quantizes the already learned model as it is, while QAT reflects the quantization process during learning to help parameters correct the 'quantization error' when learning. In other words, the efficiency of PTQ drops sharply when the bit-width is extended low<a href="https://arxiv.org/abs/2402.11295">[8]</a>, suggesting the insight that QAT is essential for extreme low bit training.


## Contribution & Conclusion

In this blog post, we conducted a comprehensive review of major 1-bit and sub-1-bit quantization studies published since 2023. We found that PTQ (Post-Training Quantization) approaches typically require model sizes of 31.6–47.8 B, whereas QAT (Quantization-Aware Training) methods only need 5–6.7 B. These insights offer crucial guidelines for balancing performance targets and resource constraints when designing and deploying 1-bit LLMs.


## Limitation
These quantified values may be somewhat inaccurate because not all existing 1-bit training methods are included and an approximation process is included. Therefore, it is a result that requires additional verification.

---
<small>

## Reference
<a href="https://arxiv.org/abs/2502.13179">1. **PTQ1.61: Push the Real Limit of Extremely Low-Bit Post-Training Quantization Methods for Large Language Models**</a> 

Zhao, J., Zhang, M., Wang, M., Shang, Y., Zhang, K., Guan, W., Wang, Y., Zhang, M. (2025) arXiv:2502.13179
<br>

<a href="https://link.springer.com/chapter/10.1007/978-3-319-46493-0_32">2. **XNOR-Net: ImageNet Classification Using Binary Convolutional Neural Networks**</a>

 Rastegari, M., Ordonez, V., Redmon, J., Farhadi, A. (2016) arXiv:1603.05279
<br>

<a href="https://arxiv.org/abs/2310.11453">3. **BitNet: Scaling 1-bit Transformers for Large Language Models**</a>

 Wang, H., Ma, S., Wei, F.*, et al. (2023) arXiv:2310.11453
<br>

<a href="https://arxiv.org/abs/2402.17764">4. **The Era of 1-bit LLMs: All Large Language Models are in 1.58 Bits**
</a>

 Ma, S., Wang, H., Ma, L., Wang, L., Wang, W., Huang, S., Dong, L., Wang, R., Xue, F., Gu, Y., Xue, F.* (2024) arXiv:2402.17764
<br>

<a href="https://arxiv.org/abs/2408.01803">5. **STBLLM: BREAKING THE 1-BIT BARRIER WITH STRUCTURED BINARY LLMS**
</a>

 Dong, P., Li, L., Zhong, Y., Du, D., Fan, R., Chen, Y., Tang, Z., Wang, Q., Xue, F., Guo, Y., Chu, X.* (2024) arXiv:2408.01803
<br>

<a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4987078">6. **PT-BitNet: Scaling up the 1-Bit Large Language Model with Post-Training Quantization**
</a>

 Guo, Y., Hao, Z., Shao, J., Zhou, J., Liu, X., Tong, X., Zhang, Y., Chen, Y., Chen, Y., Peng, W. & Ma, Z.** (2024)
<br>

<a href="https://arxiv.org/abs/2504.18415">7. **BitNet v2: Native 4-bit Activations with Hadamard Transformation for 1-bit LLMs** 
</a>

 Wang, H., Ma, S., Wei, F.* (2025) arXiv:2504.18415
<br>

<a href="https://arxiv.org/abs/2402.11295">8. **OneBit: Towards Extremely Low-bit Large Language Models**
</a>

 Xu, Y., Han, X., Yang, Z., Wang, S., Zhu, Q., Liu, Z., Liu, W., Che, W.* (2024) arXiv:2402.11295