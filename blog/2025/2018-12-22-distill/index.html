<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h2 id="introduction">Introduction</h2> <p>Since the introduction of the Transformer architecture, large language models have leveraged tens to hundreds of billions of parameters to achieve remarkable language generation capabilities. However, such massive model scales dramatically increase cloud operating costs, GPU memory requirements, and power consumption, making real-world deployment and low-power edge use difficult. To mitigate these challenges, 8-bit and 4-bit quantization techniques have been adopted to reduce memory usage with minimal performance loss compared to FP16, but when bit-width is reduced below 2 bits, both perplexity and zero-shot accuracy suffer drastic degradation.</p> <div style="text-align: center;"> <img src="/assets/img/modelsizeup.png" alt="BitNet Architecture"> </div> <p><br> Extreme 1-bit quantization offers the potential to reduce storage and bandwidth requirements by up to 32√ó[^2], but to offset the information loss from lower bit-widths, the model must be scaled up significantly. Conversely, an overly large model diminishes the gains in memory and compute reduction, so identifying the ‚Äúoptimal model size‚Äù that maintains FP16-level performance while still achieving efficient resource savings is essential.</p> <p>In particular, PTQ (Post-Training Quantization) and QAT (Quantization-Aware Training) require very different model scales, yet to date no study has quantitatively defined the optimal sizes for these two approaches. In this work, we conduct a thorough survey of the leading 1-bit training methods published since 2023 and experimentally determine the PTQ- and QAT-optimized model scales, providing concrete guidelines for balancing target performance and resource constraints when designing and deploying 1-bit LLMs. [^2]: Rastegari et al. (2016). ‚ÄúXNOR-Net: ImageNet Classification Using Binary Convolutional Neural Networks.‚Äù ECCV. ‚Äî</p> <h2 id="related-work-about-quantization-method-1-bit-or-sub-1-bit">Related work about quantization method (1-bit or sub 1-bit)</h2> <h3 id="ptq-vs-qat">PTQ vs QAT</h3> <h3 id="bitnet">BitNet</h3> <p>This was the first study to introduce QAT to a 1-bit LLM. In that paper, the authors proposed a scalable and stable 1-bit Transformer architecture and, in particular, introduced BitLinear, a 1-bit weight layer that can replace the standard fully connected layer.</p> <div style="text-align: center;"> <img src="/assets/img/BitNet.png" alt="BitNet Architecture" style="max-width: 100%; height: 300px; object-fit: contain;"> </div> <p><br> BitNet retains the familiar Transformer stacking of self-attention and feed-forward blocks, but replaces all weight matrix multiplications with BitLinear, which uses 1-bit weights. All other operations‚Äîincluding residual connections and LayerNorm‚Äîremain in 8-bit precision. This design choice is justified because (1) residual paths and LayerNorm incur only negligible compute and memory cost compared to the core Transformer operations, and (2) high-precision probabilities are required for accurate sampling.</p> <ol> <li> <p><strong>Weight Binarization</strong><br> First, the weight (W) is binarized to ({+1, -1}) via a sign function.<br> To zero-center the weights, subtract the mean (\alpha), then use the scale factor (\alpha) to minimize the binarization error.</p> \[\alpha = \frac{1}{nm} \sum_{i,j} W_{ij}, \quad \widetilde{W} = \operatorname{Sign}(W - \alpha), \quad \operatorname{Sign}(x) = \begin{cases} +1, &amp; x &gt; 0,\\ -1, &amp; x \le 0. \end{cases}\] </li> <li> <p><strong>Activation AbsMax Quantization</strong><br> The activation (x) is quantized to (b) bits.</p> \[\widetilde{x} = \mathrm{Quant}(x) = \mathrm{Clip}\!\Bigl(x \times \tfrac{Q_b}{\gamma},\,-Q_b + \epsilon,\;Q_b - \epsilon\Bigr), \\ \mathrm{Clip}(z,a,b) = \max\!\bigl(a,\min(b,z)\bigr), \\ \gamma = \|x\|_\infty.\] <p>Then, subtract the minimum (\eta = \min_{i,j} x_{ij}) from all values to shift into a fixed positive range, and apply the same quantization:</p> \[\widetilde{x} = \mathrm{Quant}(x) = \mathrm{Clip}\!\Bigl((x - \eta)\times \tfrac{Q_b}{\gamma},\,-Q_b+\epsilon,\;Q_b-\epsilon\Bigr), \quad \eta = \min_{i,j} x_{ij}.\] </li> <li> <p><strong>Matrix Multiplication</strong><br> Perform matrix multiplication using the binarized weight (\widetilde{W}) and the quantized activation (\widetilde{x}):</p> \[y = \widetilde{W}\,\widetilde{x}.\] </li> <li> <p><strong>LayerNorm for Variance Preservation</strong><br> To ensure the output variance (\mathrm{Var}(y)\approx 1), apply LayerNorm before activation quantization.<br> Using Sub-LayerNorm and the aforementioned quantization methods, the BitLinear layer is defined as:</p> <p>\(\begin{aligned} y &amp;= \widetilde{W}\,\mathrm{Quant}\bigl(\mathrm{LN}(x)\bigr)\times \frac{\beta\,\gamma}{Q_b},\\ \mathrm{LN}(x) &amp;= \frac{x - \mathbb{E}[x]}{\sqrt{\mathrm{Var}(x) + \epsilon}}, \quad \beta = \frac{1}{nm}\|W\|_{1}. \end{aligned}\)</p> <h3 id="bitnet-158">BitNet 1.58</h3> <p>Based on the BitNet Transformer architecture (replacing <code class="language-plaintext highlighter-rouge">nn.Linear</code> with <code class="language-plaintext highlighter-rouge">BitLinear</code>), BitNet b1.58 trains with <strong>1.58-bit weights</strong> and <strong>8-bit activations</strong>.</p> </li> </ol> <ul> <li>All weight parameters are fixed to <strong>({-1, 0, +1})</strong>,<br> preserving BitNet‚Äôs compression and compute advantages while<br> virtually eliminating standard matrix multiplications.</li> </ul> <div style="text-align: center;"> <img src="/assets/img/bitnet1.58.png" alt="BitNet Architecture"> </div> <p><br></p> <ul> <li>Key benefits: <ol> <li>Dramatically reduced memory footprint.</li> <li>Explicit feature filtering via zero-valued weights improves performance.</li> <li>Perplexity and downstream task performance are on par with FP16. <br> </li> </ol> </li> </ul> <p><strong>AbsMean Quantization Function</strong></p> <ol> <li> <strong>Scaling</strong> Scale the weight matrix (W) by its average absolute value (\gamma).</li> <li> <strong>Round &amp; Clip</strong> Round and clamp each element to the nearest value in ({-1, 0, +1}).<br> \(\widetilde{W} = \mathrm{RoundClip}\!\Bigl(\frac{W}{\gamma + \epsilon}, -1, +1\Bigr),\) \(\mathrm{RoundClip}(x,a,b) = \max\bigl(a,\min(b,\mathrm{round}(x))\bigr),\) \(\gamma = \frac{1}{nm}\sum_{i,j} |W_{ij}|.\)</li> </ol> <h3 id="sub-1-bit-quantization-stbllm">Sub 1-bit Quantization: STBLLM</h3> <p>STBLLM (Structured Binary LLM) is a new compression framework that structurally binarizes large language models (LLMs) beyond conventional 1-bit precision. While LLMs offer state-of-the-art performance, their high memory and compute demands limit deployment on resource-constrained environments. STBLLM observes that flipping a portion of binary weights in 1-bit LLMs does <strong>not significantly degrade performance</strong>, suggesting room for more aggressive compression.</p> <div style="text-align: center;"> <img src="/assets/img/stbllm_1.png" alt="BitNet Architecture"> </div> <p><br></p> <p><strong>1. Structured Sparsity with N:M Pattern</strong></p> <ul> <li>STBLLM employs N:M structured pruning to encode (N) non-zero weights in every (M)-slot group, enabling <strong>extremely high compression</strong>. <br> </li> <li>This pattern is also hardware-friendly and supports <strong>accelerated inference</strong>.</li> </ul> <p><strong>2. Standardized Importance (SI) Metric</strong></p> <ul> <li>To overcome the instability of Hessian-based importance scores, STBLLM proposes a lightweight importance metric that considers both weight magnitude and input feature norm. <br> </li> <li>Importance formula:<br> \(S_{i,j} = \sigma\bigl(\mu(|W_{i,j}|)\bigr) \cdot \left\| X_{:,j} \right\|_2\) <ul> <li>( \mu ): Mean of absolute weights</li> <li>( \sigma ): Normalization function</li> <li>( X ): Input feature matrix</li> </ul> </li> </ul> <p><strong>3. Layer-wise Adaptive Binarization</strong></p> <ul> <li>Each layer‚Äôs relative importance (\alpha_i) is computed and used to apply <strong>aggressive compression for less critical layers</strong>, and <strong>preserve more precision in key layers</strong>. <br> </li> <li>Formula:<br> \(\alpha_i = \frac{\omega_i}{\omega_{\text{total}}}\) <ul> <li>( \omega_i = |W_i|_2 ): L2 norm of layer (i)</li> <li>( \omega_{\text{total}} ): Sum of norms across all layers</li> </ul> </li> </ul> <p><strong>4. Non-salient Aware Quantization</strong></p> <ul> <li>Weights are divided into three zones based on their importance: <strong>sparse</strong>, <strong>intermediate</strong>, and <strong>dense</strong>. <br> </li> <li>Different binarization strategies are applied to each zone to reduce total bit usage while maintaining task-level performance.</li> </ul> <blockquote> <p>üí° <strong>STBLLM</strong> achieves sub-1bit quantization (as low as <strong>0.55 bits</strong>) on models like <strong>LLaMA, OPT, Mistral</strong>,<br> with <strong>up to 20√ó lower perplexity</strong> compared to existing 1-bit baselines.</p> </blockquote> <hr> <h2 id="methodology-for-finding-the-optimal-model-size">Methodology for Finding the Optimal Model Size</h2> <p>Earlier, we emphasized that pinpointing the ‚Äúoptimal model size‚Äù that preserves FP16-level performance while maximizing resource savings is essential. In practice, however, we face several hurdles: <strong>1. Heterogeneity of Datasets and Evaluation Metrics</strong></p> <ul> <li>Different papers use varied zero-shot benchmarks (ARC, HellaSwag, WinoGrande, etc.) and evaluation metrics, and even on the same benchmark the baseline accuracy can differ widely, making simple averages misleading.</li> </ul> <p><strong>2. Incompleteness in the Perplexity Perspective</strong></p> <ul> <li>Some methods report better PPL than the FP16 baseline at smaller scales, while other studies simply do not provide PPL data below a certain size, resulting in incomplete comparisons.</li> </ul> <p>To overcome these challenges, our study successfully quantifies the optimal model scales through the following procedure:</p> <h3 id="zero-shot-accuracy-perspective">Zero-shot Accuracy Perspective</h3> <p><strong>1. Extracting the 90% Threshold</strong></p> <ul> <li>For each paper and zero-shot benchmark, we determine the minimum model size required to reach 90% of the FP16 baseline accuracy.</li> </ul> <p><strong>2. Adjusting for Under-Reporting</strong></p> <ul> <li>If even the largest reported scale fails to hit 90%, we multiply that maximum scale by 1.5 to estimate the required size (e.g., if a 3B model falls short, we assume 4.5B would meet the threshold).</li> </ul> <p><strong>3. Averaging</strong></p> <ul> <li>We first average the required scales across shared benchmarks (ARC, HellaSwag, etc.), then compute separate averages for PTQ and QAT to obtain representative values.</li> </ul> <h3 id="perplexity-perspective">Perplexity Perspective</h3> <p><strong>1. Establishing a PPL ‚â§ 10 Criterion</strong></p> <ul> <li>Because some methods exceed the baseline PPL and others omit data, we set a consistent standard of PPL ‚â§ 10.</li> </ul> <p><strong>2. Collecting Required Scales</strong></p> <ul> <li>We gather the model sizes reported for PTQ and QAT methods that satisfy the PPL ‚â§ 10 criterion.</li> </ul> <p><strong>3. Averaging</strong></p> <ul> <li>We average these scales separately for PTQ and QAT, yielding comparable insights between the two approaches.</li> </ul> <h3 id="seperation-for-ptq-vs-qat">Seperation for PTQ vs QAT</h3> <p>PTQ and QAT demand significantly different optimal model sizes, so it is necessary to quantify each quantization approach‚Äôs optimal scale independently.</p> <hr> <h2 id="results">Results</h2> <hr> <h2 id="conclusion">Conclusion</h2> <p>You can add interative plots using plotly + iframes <img class="emoji" title=":framed_picture:" alt=":framed_picture:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f5bc.png" height="20" width="20"></p> <hr> <h2 id="details-boxes">Details boxes</h2> <hr> <h2 id="mermaid">Mermaid</h2> <p>This theme supports creating diagrams directly in markdown using <a href="https://mermaid.js.org/" rel="external nofollow noopener" target="_blank">Mermaid</a>.</p> <pre><code class="language-mermaid">gantt
    dateFormat  YYYY-MM-DD
    title A Gantt Diagram

    section Section
    Task A           :a1, 2025-01-01, 30d
    Task B           :after a1, 20d
    Task C           :2025-01-10, 12d
</code></pre> <p>It will be presented as:</p> <pre><code class="language-mermaid">classDiagram
direction LR
    class Animal {
        +String species
        +int age
        +makeSound()
    }
    class Dog {
        +String breed
        +bark()
    }
    class Cat {
        +String color
        +meow()
    }
    class Bird {
        +String wingSpan
        +fly()
    }
    class Owner {
        +String name
        +int age
        +adoptAnimal(Animal animal)
    }

    Animal &lt;|-- Dog
    Animal &lt;|-- Cat
    Animal &lt;|-- Bird
    Owner "1" --&gt; "0..*" Animal

    Dog : +fetch()
    Cat : +purr()
    Bird : +sing()
</code></pre> <p>With Mermaid, you can easily add clear and dynamic diagrams to enhance your blog content.</p> <hr> <h2 id="diff2html">Diff2Html</h2> <h2 id="leaflet">Leaflet</h2> <h2 id="chartjs-echarts-and-vega-lite">Chartjs, Echarts and Vega-Lite</h2> <hr> <h2 id="tikz">TikZ</h2> <hr> <h2 id="typograms">Typograms</h2> <p><a href="https://google.github.io/typograms/" rel="external nofollow noopener" target="_blank">Typograms</a> are a way of combining text and g</p> <h2 id="layouts">Layouts</h2> <p>T</p> <hr> <h2 id="other-typography">Other Typography?</h2> <p>Here‚Äôs our logo (hover to see the title text):</p> <p>Inline-style: <img src="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png" alt="alt text" title="Logo Title Text 1"></p> <p>Reference-style: <img src="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png" alt="alt text" title="Logo Title Text 2"></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>No language indicated, so no syntax highlighting.
But let's throw in a &lt;b&gt;tag&lt;/b&gt;.
</code></pre></div></div> <p>Colons can be used to align columns.</p> <table> <thead> <tr> <th>Tables</th> <th style="text-align: center">Are</th> <th style="text-align: right">Cool</th> </tr> </thead> <tbody> <tr> <td>col 3 is</td> <td style="text-align: center">right-aligned</td> <td style="text-align: right">$1600</td> </tr> <tr> <td>col 2 is</td> <td style="text-align: center">centered</td> <td style="text-align: right">$12</td> </tr> <tr> <td>zebra stripes</td> <td style="text-align: center">are neat</td> <td style="text-align: right">$1</td> </tr> </tbody> </table> <p>There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don‚Äôt need to make the raw Markdown line up prettily. You can also use inline Markdown.</p> <table> <thead> <tr> <th>Markdown</th> <th>Less</th> <th>Pretty</th> </tr> </thead> <tbody> <tr> <td><em>Still</em></td> <td><code class="language-plaintext highlighter-rouge">renders</code></td> <td><strong>nicely</strong></td> </tr> <tr> <td>1</td> <td>2</td> <td>3</td> </tr> </tbody> </table> <blockquote> <p>Blockquotes are very handy in email to emulate reply text. This line is part of the same quote.</p> </blockquote> <p>Quote break.</p> <blockquote> <p>This is a very long line that will still be quoted properly when it wraps. Oh boy let‚Äôs keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can <em>put</em> <strong>Markdown</strong> into a blockquote.</p> </blockquote> <p>Here‚Äôs a line for us to start with.</p> <p>This line is separated from the one above by two newlines, so it will be a <em>separate paragraph</em>.</p> <p>This line is also a separate paragraph, but‚Ä¶ This line is only separated by a single newline, so it‚Äôs a separate line in the <em>same paragraph</em>.</p> </body></html>